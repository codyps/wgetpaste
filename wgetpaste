#!/bin/bash
# A Script that automates pasting to a number of pastebin services
# relying only on bash, sed, coreutils (mktemp/sort/tr/wc/whoami) and wget
# Copyright (c) 2007 Bo Ã˜rsted Andresen <bo.andresen@zlin.dk>
# Distributed as-is. With no warranties.

VERSION="2.5"

### helper functions

# show error message(s) and die
die() {
	echo "$@" >&2
	exit 1
}

# escape % (used for escaping), & (used as separator in POST data), + (used as space in POST data) and space
escape() {
	sed -e 's|%|%25|g' -e 's|&|%26|g' -e 's|+|%2b|g' -e 's| |+|g' <<< "$*"
}	

get_from_clipboard() {
	if [[ -x $(type -P xclip) ]]; then
		xclip -o
	else
		cat <<EOF >&2
Could not find xclip on your system. In order to use --xcut you must
either emerge x11-misc/xclip or define get_from_clipboard() globally in
/etc/wgetpaste or per user in ~/.wgetpaste to use another program
(such as xcut or klipper) to read from your clipboard.
EOF
		exit 1		
	fi
}

add_to_clipboard() {
	if [[ -x $(type -P xclip) ]]; then
		xclip -loops 10 <<< "$*"
	else
		cat <<EOF >&2
Could not find xclip on your system. In order to use --xpaste you must
either emerge x11-misc/xclip or define add_to_clipboard() globally in
/etc/wgetpaste or per user in ~/.wgetpaste to use another program
(such as xcut or klipper) to write to your clipboard.
EOF
		exit 1
	fi
}

showurl() {
	echo "Your ${2}paste can be seen here: $1"
	[[ $XPASTE ]] && add_to_clipboard "$1"
}

# Used for --info and --info-only
INFO_COMMAND="emerge --info"
INFO_ARGS="--ignore-default-opts"

### services
SERVICES="ca rafb osl sh"
# ca
ENGINE_ca=ca
URL_ca="http://pastebin.ca/"
SIZE_ca="1024000 1%MB"
# rafb
ENGINE_rafb=rafb
URL_rafb="http://rafb.net/paste/ paste.php"
SIZE_rafb="800000 800%kB"
LINES_rafb=10000
TOOFAST_rafb="http://rafb.net/p/toofast.html You must wait at least 10 seconds between each paste! Try again in 10 seconds."
TOOBIG_rafb="http://rafb.net/p/toobig.html The paste is too big. Try another service or paste smaller chunks of data."
EXPIRATION_INFO_rafb="Pastes on rafb: http://rafb.net/paste/ expire after 24 hours."$'\n'
# osl
ENGINE_osl=osl
URL_osl="http://pastebin.osuosl.org/ pastebin.php"
# sh
ENGINE_sh=sh
URL_sh="http://sh.nu/p/"

### engines
# ca
LANGUAGES_ca="Plain%Text Asterisk%Configuration C C++ PHP Perl Java VB C# Ruby Python Pascal \
mIRC PL/I XML SQL Scheme ActionScript Ada Apache%Configuration Assembly%(NASM) ASP Bash CSS \
Delphi HTML%4.0%Strict JavaScript LISP Lua Microprocessor%ASM Objective%C VB.NET"
LANGUAGE_COUNT_ca=0
EXPIRATIONS_ca="Never 5%minutes 10%minutes 15%minutes 30%minutes 45%minutes 1%hour 2%hours \
4%hours 8%hours 12%hours 1%day 2%days 3%days 1%week 2%weeks 3%weeks 1%month 2%months \
3%months 4%months 5%months 6%months 1%year"
POST_ca="s=Submit+Post name description type expiry % content"
REGEX_URL_ca='s|^.*content="[0-9]\+;\(http://[^/]\+/[0-9]\+\)".*$|\1|p'
REGEX_RAW_ca='s|^\(http://[^/]\+/\)\([0-9]\+\)$|\1raw/\2|'
# rafb
LANGUAGES_rafb="C C89 C99 C++ C# Java Pascal Perl PHP PL/I Python Ruby SQL VB Plain%Text"
POST_rafb="% nick desc lang % cvt_tabs text"
REGEX_RAW_rafb='s|html\?$|txt|'
# osl
LANGUAGES_osl="Plain%Text ActionScript Ada Apache%Log%File AppleScript Assembly%(NASM) \
ASP Bash C C%for%Macs CAD%DCL CAD%Lisp C++ C# ColdFusion CSS D Delphi Diff DOS Eiffel Fortran \
FreeBasic Game%Maker HTML%4.0%Strict INI%file Java Javascript Lisp Lua MatLab Microprocessor%ASM \
MySQL NullSoft%Installer Objective%C OCaml Openoffice.org%BASIC Oracle%8 Pascal Perl PHP Python \
QBasic Robots.txt Ruby Scheme Smarty SQL TCL VB VB.NET VisualFoxPro XML"
LANGUAGE_VALUES_osl="text actionscript ada apache applescript asm asp bash c c_mac caddcl \
cadlisp cpp csharp cfm css d delphi diff dos eiffel fortran freebasic gml html4strict ini java \
javascript lisp lua matlab mpasm mysql nsis objc ocaml oobas oracle8 pascal perl php python \
qbasic robots ruby scheme smarty sql tcl vb vbnet visualfoxpro xml"
EXPIRATIONS_osl="Never 1%day 1%month"
EXPIRATION_VALUES_osl="f d m"
POST_osl="paste=Send poster % format expiry % code2"
REGEX_RAW_osl='s|^\(http://[^/]\+/\)\([0-9]\+\)$|\1pastebin.php?dl=\2|'
# sh
POST_sh="% poster % % % % code"

### defaults
for f in {/etc/,~/.}wgetpaste{.d/*.bash,}; do
	[[ -f $f ]] && . "$f"
done
DEFAULT_NICK=${DEFAULT_NICK:-$(whoami)}
DEFAULT_SERVICE=${DEFAULT_SERVICE:-rafb}
DEFAULT_LANGUAGE=${DEFAULT_LANGUAGE:-Plain Text}
DEFAULT_EXPIRATION=${DEFAULT_EXPIRATION:-1 month}

### usage

usage() {
	cat <<EOF
Usage: $0 [options] [file[s]]

Options:
    -l, --language LANG           set language (defaults to "$DEFAULT_LANGUAGE")
    -d, --description DESCRIPTION set description (defaults to "stdin" or filename)
    -n, --nick NICK               set nick (defaults to your username))
    -s, --service SERVICE         set service to use (defaults to "$DEFAULT_SERVICE")
    -e, --expiration EXPIRATION   set when it should expire (defaults to "$DEFAULT_EXPIRATION")

    -S, --list-services           list supported pastebin services
    -L, --list-languages          list languages supported by the specified service
    -E, --list-expiration         list expiration setting supported by the specified service

    -c, --command COMMAND         paste COMMAND and the output of COMMAND
    -i, --info                    append the output of \`$INFO_COMMAND\`
    -I, --info-only               paste the output of \`$INFO_COMMAND\` only
    -x, --xcut                    read input from clipboard (requires x11-misc/xclip)
    -X, --xpaste                  write resulting url to clipboard (requires x11-misc/xclip)

    -r, --raw                     show url for the raw paste (no syntax highlighting or html)
    -v, --verbose                 show wget stderr output if no url is received
        --debug                   be *very* verbose (implies -v)

    -h, --help                    show this help
        --version                 show version information

Defaults (DEFAULT_{NICK,SERVICE,LANGUAGE,EXPIRATION}[_\${SERVICE}]) can be overridden
globally in /etc/wgetpaste or /etc/wgetpaste.d/*.bash or per user in any of ~/.wgetpaste
or ~/.wgetpaste.d/*.bash.
EOF
}

### show functions

showservices() {
	echo "Services supported: (case sensitive):"
	local max s IND INDV engine url
	max=0
	for s in $SERVICES; do
		[[ ${#s} -gt $max ]] && max=${#s}
	done
	((IND=6+max))
	if [[ $VERBOSE ]]; then
		max=0
		for s in $SERVICES; do
			s=URL_$s
			s=${!s% *}
			[[ ${#s} -gt $max ]] && max=${#s}
		done
		((INDV=3+max+IND))
	fi
	for s in $SERVICES; do
		[[ $VERBOSE ]] && engine=ENGINE_$s && engine=$'\e'"[${INDV}G- ${!engine}"
		url=URL_$s
		url=${!url% *}
		echo "    $s "$'\e'"[${IND}G- $url$engine"
	done | sort
}

showlanguages() {
	echo "Languages supported by $(getrecipient) (case sensitive):"
	local l lang
	lang=LANGUAGES_$ENGINE
	[[ -z ${!lang} ]] && echo $'\n'"\"$ENGINE\" has no support for setting language." >&2
	for l in ${!lang}; do
		echo "    ${l//%/ }"
	done | sort
}

showexpirations() {
	echo "Expiration options supported by $(getrecipient) (case sensitive):"
	local e expiration info
	expiration=EXPIRATIONS_$ENGINE
	info=EXPIRATION_INFO_$SERVICE
	[[ -z ${!expiration} ]] && echo $'\n'"${!info}\"$ENGINE\" has no support for setting expiration." >&2
	for e in ${!expiration}; do
		echo "    ${e//%/ }"
	done
}

### verify functions

verifyservice() {
	for s in $SERVICES; do
		[[ $s == $* ]] && return 0
	done
	echo "\"$*\" is not a supported service."$'\n' >&2
	showservices >&2
	exit 1
}

verifylanguage() {
	local i j l lang count v values
	lang=LANGUAGES_$ENGINE
	count=LANGUAGE_COUNT_$ENGINE
	values=LANGUAGE_VALUES_$ENGINE
	if [[ -n ${!lang} ]]; then
		((i=0))
		for l in ${!lang}; do
			if [[ $LANGUAGE == ${l//%/ } ]]; then
				if [[ -n ${!count} ]]; then
					((LANGUAGE=i+1))
				elif [[ -n ${!values} ]]; then
					((j=0))
					for v in ${!values}; do
						[[ i -eq j ]] && LANGUAGE=${v//%/ } && break
						((j++))
					done
				fi
				return 0
			fi
			((i++))
		done
	else
		[[ $LANGUAGESET = 0 ]] || return 0
	fi
	echo "\"$LANGUAGE\" is not a supported language for $(getrecipient)."$'\n' >&2
	showlanguages >&2
	exit 1
}

verifyexpiration() {
	local i j e expiration count v values
	expiration=EXPIRATIONS_$ENGINE
	count=EXPIRATION_COUNT_$ENGINE
	values=EXPIRATION_VALUES_$ENGINE
	if [[ -n ${!expiration} ]]; then
		((i=0))
		for e in ${!expiration}; do
			if [[ ${EXPIRATION} == ${e//%/ } ]]; then
				if [[ -n ${!count} ]]; then
					((EXPIRATION=i+1))
				elif [[ -n {!values} ]]; then
					((j=0))
					for v in ${!values}; do
						[[ i -eq j ]] && EXPIRATION=${e//%/ } && break
						((j++))
					done
				fi
				return 0
			fi
			((i++))
		done
	else
		[[ $EXPIRATIONSET = 0 ]] || return 0
	fi
	echo "\"$EXPIRATION\" is not a supported expiration option for $(getrecipient)."$'\n' >&2
	showexpirations >&2
	exit 1
}

### Posting helper functions

# get the url to post to for any given service
getrecipient() {
	local urls target serv
	for s in $SERVICES; do
		if [[ $s == $SERVICE ]]; then
			urls=URL_$SERVICE
			if [[ RAW == $1 ]]; then
				[[ ${!urls} = ${!urls#* } ]] || target=${!urls#* }
			else
				serv="$SERVICE: "
			fi
			echo "${serv}${!urls% *}${target}"
			return 0
		fi
	done
	die "Failed to get url for \"$SERVICE\"."
}

# print a warning if failure is predictable due to the mere size of the paste. sh seems to be the most reliable
# service in that regard. note that this is only a warning printed. it does not abort.
warnings() {
	warn() {
		if [[ -n $2 && $1 -gt $2 ]]; then
			echo "Pasting > $3 often tend to fail with $SERVICE. Use --verbose or --debug to see the"
			echo "error output from wget if it fails. Alternatively use another pastebin service like e.g. sh."
		fi
	}
	local size lines
	size=SIZE_$SERVICE
	lines=LINES_$SERVICE
	warn "$SIZE" "${!size% *}" "${!size#* }"
	warn "$LINES" "${!lines}" "${!lines} lines"
}

postdata() {
	local post nr extra nick desc lang exp tabs text
	post=POST_$ENGINE
	nr=${!post//[^ ]}
	[[ 6 = ${#nr} ]] || die "\"${SERVICE}\" is not supported by ${FUNCNAME}()."
	extra=${!post%% *}
	[[ -n $extra ]] && echo -n "$extra&"
	post=${!post#* }
	nick=${post%% *}
	[[ % = $nick ]] || echo -n "$nick=$NICK&"
	post=${post#* }
	desc=${post%% *}
	[[ % = $desc ]] || echo -n "$desc=$DESCRIPTION&"
	post=${post#* }
	lang=${post%% *}
	[[ % = $lang ]] || echo -n "$lang=$LANGUAGE&"
	post=${post#* }
	exp=${post%% *}
	[[ % = $exp ]] || echo -n "$exp=$EXPIRATION&"
	post=${post#* }
	tabs=${post%% *}
	[[ % = $tabs ]] || echo -n "$tabs=$CVT_TABS&"
	text=${post#* }
	echo "$text=$INPUT"
}

geturl() {
	local regex
	regex=REGEX_URL_$ENGINE
	if [[ -n ${!regex} ]]; then
		[[ needstdout = $1 ]] && return 0
		sed -n "${!regex}" <<< "$*"
	else
		[[ needstdout = $1 ]] && return 1
		sed -n 's|^.*Location:\ \(http://[^\ ]\+\).*$|\1|p' <<< "$*"
	fi
}

# verify that the pastebin service did not return a known error url. otherwise print a helpful error message
verifyurl() {
	dieifknown() {
		[[ -n ${!1%% *} && ${!1%% *} == $URL ]] && die "${!1#* }"
	}
	local t
	for t in ${!TOO*}; do
		[[ $t == TOO*_$SERVICE ]] && dieifknown "$t"
	done
}

# if possible convert URL to raw
converttoraw() {
	local regex
	regex=REGEX_RAW_$ENGINE
	if [[ -n ${!regex} ]]; then
		RAWURL=$(sed -e "$regex" <<< "$URL")
		return 0
	fi
	echo "Raw download of pastes is not supported by $(getrecipient)." >&2
	return 1
}

### read cli options

# convert groups of short options to singular short options. convert long options to short options.
while [[ -n $1 ]]; do
	case "$1" in
		-- )
		for arg in "$@"; do
			ARGS[${#ARGS[*]}]="$arg"
		done
		break
		;;
		--debug )
		set -x
		DEBUG=0
		;;
		--*=* )
		ARGS[${#ARGS[*]}]="${1%%=*}"
		ARGS[${#ARGS[*]}]="${1#*=}"
		;;
		--* )
		ARGS[${#ARGS[*]}]="$1"
		;;
		-* )
		for shortarg in $(sed 's|.| -&|g' <<< "${1#-}"); do
			ARGS[${#ARGS[*]}]="$shortarg"
		done
		;;
		* )
		ARGS[${#ARGS[*]}]="$1"
	esac
	shift
done

# set the converted options as input
set -- "${ARGS[@]}"

noargument() {
	die "$0: option $1 requires an argument"
}

getfilenames() {
	for f in "$@"; do
		[[ -f $f ]] || die "$0: $f No such file found."
		SOURCE="files"
		FILES[${#FILES[*]}]="$f"
	done
}

while [[ -n $1 ]]; do
	case "$1" in
		-- )
		shift && getfilenames "$@" && break
		;;
		-c | --command )
		[[ -z $2 ]] && noargument "$1"
		SOURCE="command"
		COMMANDS[${#COMMANDS[*]}]="$2"
		shift 2
		;;
		-d | --description )
		[[ -z $2 ]] && noargument "$1"
		DESCRIPTION="$2"
		shift 2
		;;
		-e | --expiration )
		[[ -z $2 ]] && noargument "$1"
		EXPIRATIONSET=0
		EXPIRATION="$2"
		shift 2
		;;
		-E | --list-expiration )
		LISTEXPIRATION=0
		shift
		;;
		-h | --help )
		usage && exit 0
		;;
		-i | --info )
		INFO=0
		shift
		;;
		-I | --info-only )
		SOURCE=info
		shift
		;;
		-l | --language )
		[[ -z $2 ]] && noargument "$1"
		LANGUAGESET=0
		LANGUAGE="$2"
		shift 2
		;;
		-L | --list-languages )
		LISTLANGUAGES=0
		shift
		;;
		-n | --nick )
		[[ -z $2 ]] && noargument "$1"
		NICK=$(escape "$2")
		shift 2
		;;
		-r | --raw )
		RAW=0
		shift
		;;
		-s | --service )
		[[ -z $2 ]] && noargument "$1"
		verifyservice "$2"
		SERVICE=$(escape "$2")
		shift 2
		;;
		-S | --list-services )
		SHOWSERVICES=0
		shift
		;;
		-v | --verbose )
		VERBOSE=0
		shift
		;;
		--version )
		echo "$0, version $VERSION" && exit 0
		;;
		-x | --xcut )
		SOURCE=xcut
		shift
		;;
		-X | --xpaste )
		XPASTE=0
		shift
		;;
		-* )
		die "$0: unrecognized option \`$1'"
		;;
		*)
		getfilenames "$1" && shift
		;;
	esac
done

### everything below this should be independent of which service is being used...

# show services if requested (need to respect --verbose if specified)
[[ $SHOWSERVICES ]] && showservices && exit 0

# set default service, nick, source and tabs convertion
SERVICE=${SERVICE:-${DEFAULT_SERVICE}}
ENGINE=ENGINE_$SERVICE
ENGINE="${!ENGINE}"
default="DEFAULT_NICK_$SERVICE" && [[ -n ${!default} ]] && NICK=${NICK:-${!default}}
NICK=${NICK:-$(escape "${DEFAULT_NICK}")}
[[ -z $SOURCE ]] && SOURCE="stdin" && FILES[${#FILES[*]}]="/dev/stdin"
CVT_TABS=No

# show languages if requested (needs to be done after the right service is selected)
[[ $LISTLANGUAGES ]] && showlanguages && exit 0

# show expiration options if requested (needs to be done after the right service is selected)
[[ $LISTEXPIRATION ]] && showexpirations && exit 0

# language needs to be verified before it is escaped but after service is selected
default="DEFAULT_LANGUAGE_$SERVICE" && [[ -n ${!default} ]] && LANGUAGE=${LANGUAGE:-${!default}}
LANGUAGE=${LANGUAGE:-${DEFAULT_LANGUAGE}}
# uses $SERVICE and $LANGUAGE. may change the value of the latter.
verifylanguage
LANGUAGE=$(escape "$LANGUAGE")

# expiration needs to be verified before it is escaped but after service is selected
default="DEFAULT_EXPIRATION_$SERVICE" && [[ -n ${!default} ]] && EXPIRATION=${EXPIRATION:-${!default}}
EXPIRATION=${EXPIRATION:-${DEFAULT_EXPIRATION}}
# uses $SERVICE and $EXPIRATION. may change the value of the latter.
verifyexpiration
EXPIRATION=$(escape "$EXPIRATION")

# set prompt
if [[ 0 -eq $UID ]]; then
	PS1="#"
else
	PS1=$
fi

# set default description
if [[ -z $DESCRIPTION ]]; then
	case "$SOURCE" in
		info )
		DESCRIPTION="$PS1 $INFO_COMMAND;"
		;;
		command )
		DESCRIPTION="$PS1"
		for c in "${COMMANDS[@]}"; do
			DESCRIPTION="$DESCRIPTION $c;"
		done
		;;
		files )
		DESCRIPTION="${FILES[*]}"
		;;
		* )
		DESCRIPTION="$SOURCE"
		;;
	esac
fi

# read input
case "$SOURCE" in
	command )
	for c in "${COMMANDS[@]}"; do
		INPUT="${INPUT}${PS1} ${c}"$'\n'"$(bash -c "$c" 2>&1)"$'\n\n'
	done
	;;
	info )
	INPUT="$PS1 $INFO_COMMAND"$'\n'"$($INFO_COMMAND $INFO_ARGS)"
	;;
	xcut )
	INPUT="$(get_from_clipboard)"
	;;
	files | stdin )
	# handle the case where the input source (defaulting to /dev/stdin) is not readable verbosely
	if [[ ${#FILES[*]} -gt 1 ]]; then
		for f in "${FILES[@]}"; do
			[[ -r $f ]] || \
				die "The input source: \"$f\" is not readable. Please specify a readable input source."
			INPUT="${INPUT}${PS1} cat $f"$'\n'"$( < "$f" )"$'\n\n'
		done
	else
		INPUT=$( < "$FILES" )
	fi
	;;
esac
[[ -z $INPUT ]] && die "No input read. Nothing to paste. Aborting."

# append $INFO_COMMAND if needed
if [[ $INFO ]]; then
	DESCRIPTION="$DESCRIPTION $PS1 $INFO_COMMAND;"
	INPUT="$INPUT"$'\n'"$PS1 $INFO_COMMAND"$'\n'"$($INFO_COMMAND $INFO_ARGS)"
fi

# escape DESCRIPTION and INPUT
DESCRIPTION=$(escape "$DESCRIPTION")
INPUT=$(escape "$INPUT")

# print a friendly warning if the size makes failure predictable for the specified pastebin service.
SIZE=$(wc -c <<< "$INPUT")
LINES=$(wc -l <<< "$INPUT")
warnings >&2

# create temp file (wget is much more reliable reading large input from a file than from the cli directly
TEMPFILE=$(mktemp /tmp/wgetpaste.XXXXXX)
if [[ -f $TEMPFILE ]]; then
    # write paste data to the temporary file
    postdata > "$TEMPFILE" || die "Failed to write to temporary file: \"$TEMPFILE\"."
    WGETARGS="--post-file=$TEMPFILE"
else
	# fall back to using --post-data if the temporary file could not be created
	# TABs and new lines need to be escaped for wget to interpret it as one string
    WGETARGS="--post-data=$(postdata | sed -e 's|$|%0a|g' -e 's|\t|%09|g' | tr -d '\n')"
fi

# set recipient
RECIPIENT=$(getrecipient RAW)

# paste it
WGETARGS="--tries=5 --timeout=60 $WGETARGS"
if geturl needstdout || [[ $DEBUG || ! -w /dev/null ]]; then
	OUTPUT=$(LC_ALL=C wget -O - $WGETARGS $RECIPIENT 2>&1)
else
	OUTPUT=$(LC_ALL=C wget -O /dev/null $WGETARGS $RECIPIENT 2>&1)
fi

# clean temporary file if it was created
if [[ -f $TEMPFILE ]]; then
	if [[ $DEBUG ]]; then
		echo "Left temporary file: \"$TEMPFILE\" alone for debugging purposes."
	else
		rm "$TEMPFILE" || echo "Failed to remove temporary file: \"$TEMPFILE\"." >&2
	fi
fi

# get the url
URL=$(geturl "$OUTPUT")

# verify that the pastebin service did not return a known error url such as toofast.html from rafb
# uses $SERVICE and $URL.
verifyurl

# handle the case when there was no location returned
if [[ -z $URL ]]; then
	if [[ $DEBUG || $VERBOSE ]]; then
		die "Apparently nothing was received. Perhaps the connection failed."$'\n'"$OUTPUT"
	else
		echo "Apparently nothing was received. Perhaps the connection failed. Enable --verbose or" >&2
		die "--debug to get the output from wget that can help diagnose it correctly."
	fi
fi

# converttoraw() may change the value of RAW. Otherwise it set RAWURL.
if [[ $RAW ]] && converttoraw; then
	showurl "$RAWURL" "raw "
else
	showurl "$URL"
fi

exit 0
